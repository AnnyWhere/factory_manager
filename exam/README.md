# Билет по ООП на Python

## 1. Сериализация и десериализация. Файлы JSON

### Определение
**Сериализация** — процесс преобразования объектов Python в поток байтов или строку (обычно в формат JSON) для хранения или передачи.

**Десериализация** — обратный процесс восстановления объектов Python из строки или потока байтов.

### Модуль `json` в Python
Модуль `json` предоставляет методы для работы с JSON:
- `json.dump()` — сериализация в файл
- `json.dumps()` — сериализация в строку
- `json.load()` — десериализация из файла
- `json.loads()` — десериализация из строки

### Примеры кода

#### Базовый пример
```python
import json

# Данные для сериализации
data = {
    "name": "Аня",
    "age": 19,
    "is_student": True,
    "courses": ["Python", "ООП", "Алгоритмы"],
    "address": {
        "city": "Москва",
        "street": "Волгоградский проспект"
    }
}

# Сериализация в строку
json_string = json.dumps(data, ensure_ascii=False, indent=2)
print("Сериализованная строка:")
print(json_string)

# Десериализация из строки
decoded_data = json.loads(json_string)
print("\nДесериализованные данные:")
print(f"Имя: {decoded_data['name']}")
print(f"Курсы: {', '.join(decoded_data['courses'])}")

# Сериализация в файл
with open('data.json', 'w', encoding='utf-8') as f:
    json.dump(data, f, ensure_ascii=False, indent=2)

# Десериализация из файла
with open('data.json', 'r', encoding='utf-8') as f:
    loaded_data = json.load(f)
    print("\nДанные из файла:")
    print(loaded_data)
```

#### Результат

В терминале

```
Сериализованная строка:
{
  "name": "Аня",
  "age": 19,
  "is_student": true,
  "courses": [
    "Python",
    "ООП",
    "Алгоритмы"
  ],
  "address": {
    "city": "Москва",
    "street": "Волгоградский проспект"
  }
}

Десериализованные данные:
Имя: Аня
Курсы: Python, ООП, Алгоритмы

Данные из файла:
{'name': 'Аня', 'age': 19, 'is_student': True, 'courses': ['Python', 'ООП', 'Алгоритмы'], 'address': {'city': 'Москва', 'street': 'Волгоградский проспект'}}
```

Также будет создан файл data.json со следующим содержимым:

```
{
  "name": "Аня",
  "age": 19,
  "is_student": true,
  "courses": [
    "Python",
    "ООП",
    "Алгоритмы"
  ],
  "address": {
    "city": "Москва",
    "street": "Волгоградский проспект"
  }
}
```
#### Проект

В папке my_project находится один из моих мини-проектов - "Менеджер", который детально раскрывает данную тему. При желании можно посмотреть.

## 2. Проектирование классов: Иерархия работников завода

Архитектура классов
Система управления заводом построена на основе объектно-ориентированного подхода с использованием иерархии наследования. На диаграмме классов представлены основные классы и их отношения.

![Диаграмма_классов](\sources\Диаграмма_классов.png)

### Описание классов

#### 1. **Employee (Абстрактный класс работника)**
Базовый класс для всех работников завода. Содержит общие атрибуты: ID, имя, фамилию, возраст, пол. Определяет абстрактные методы `get_info()` и `get_post()` для получения информации о работнике.

#### 2. **Chief (Начальник цеха)**
Наследуется от Employee. Имеет фиксированную должность "Начальник цеха". Отвечает за управление цехом.

#### 3. **Worker (Абстрактный класс рабочего)**
Наследуется от Employee. Имеет должность "Рабочий". Определяет абстрактный метод `get_role()` для получения специализации.

#### 4. **Конкретные специализации рабочих**
- **Turner (Токарь)** - специализация "Токарь"
- **Locksmith (Слесарь)** - специализация "Слесарь"
- **Miller (Фрезеровщик)** - специализация "Фрезеровщик"

#### 5. **WorkShop (Цех)**
Представляет производственный цех. Содержит название, начальника и список работников. Реализует операции добавления, удаления и сравнения работников. Перегружает операторы для удобной работы с объектами.

#### 6. **Factory (Завод)**
Представляет весь завод. Управляет коллекцией цехов. Обеспечивает сохранение и загрузку данных в JSON-формате.

#### 7. **Menu (Фасад)**
Класс-фасад, предоставляющий упрощенный интерфейс для взаимодействия с системой. Инкапсулирует сложность работы с Factory, WorkShop и Employee классами.

#### 8. **Gender (Перечисление)**
Перечисление для представления пола работника (MALE, FEMALE).

### Хранение данных
Для хранения объектов используются списки Python:
- `Factory.__workshops` - список цехов завода
- `WorkShop.__employees` - список работников цеха
- Все объекты сериализуются в JSON для постоянного хранения

---

## 3. Программа управления заводом с JSON-сериализацией

### Функциональность программы

Программа представляет собой систему управления заводом с консольным интерфейсом, реализующую полный цикл работы с объектами: создание, хранение, сериализация, десериализация и сравнение.

### Основные возможности

#### 1. **Управление структурой завода**
- Создание и удаление цехов
- Назначение начальников цехов
- Просмотр иерархии завода

#### 2. **Управление персоналом**
- Добавление работников различных специальностей (токарь, слесарь, фрезеровщик)
- Удаление работников из цехов
- Просмотр информации о работниках
- Группировка работников по специализациям

#### 3. **Сериализация и хранение данных**
- Автоматическое сохранение состояния системы в файл `factory_data.json`
- Загрузка сохраненного состояния при запуске программы
- Логирование всех действий в файл `factory_log.json`
- Экспорт данных в структурированном JSON-формате

#### 4. **Операции сравнения**
- Сравнение цехов по распределению работников по классам
- Перегрузка оператора `==` для сравнения объектов WorkShop
- Анализ структуры персонала в разных цехах

### Архитектура программы

#### Слои приложения:
1. **Уровень данных** (`Employee`, `Worker`, `Chief`, `Turner`, `Locksmith`, `Miller`)
2. **Уровень бизнес-логики** (`WorkShop`, `Factory`)
3. **Уровень представления** (`Menu` - фасад)

#### Паттерны проектирования:
- **Наследование** - для создания иерархии классов работников
- **Абстрактные классы** - для определения общих интерфейсов
- **Перегрузка операторов** - для удобной работы с объектами
- **Фасад** - для предоставления простого интерфейса к сложной системе
- **Сериализация/Десериализация** - для сохранения состояния приложения

### JSON-форматы данных

#### Формат хранения данных завода (`factory_data.json`):
Содержит полное состояние системы, включая информацию о заводе, всех цехах и работниках. Использует вложенную структуру с сохранением типов объектов и их атрибутов.

#### Формат лога действий (`factory_log.json`):
Содержит историю всех операций, выполненных в системе. Каждая запись включает временную метку, тип действия и детали операции.

### Особенности реализации

1. **Уникальная идентификация** - каждый работник получает уникальный UUID
2. **Валидация ввода** - проверка корректности данных, вводимых пользователем
3. **Обработка ошибок** - корректная обработка исключений при работе с файлами
4. **Сравнение объектов** - цехи сравниваются по распределению работников по классам, а не просто по количеству
5. **Локализация** - поддержка русского языка в интерфейсе и данных
6. **Расширяемость** - архитектура позволяет легко добавлять новые типы работников

### Использование фасада

В качестве фасада используется класс **Menu**, который:
- Предоставляет упрощенный текстовый интерфейс для пользователя
- Инкапсулирует сложность взаимодействия с классами `Factory`, `WorkShop` и `Employee`
- Объединяет множество операций в удобные меню и подменю
- Управляет процессом сериализации и десериализации данных
- Логирует все действия пользователя

Фасад `Menu` скрывает от пользователя детали реализации системы, позволяя работать с заводом через простые команды, не требуя знаний о внутренней структуре классов.
---

## 4. Структурные паттерны проектирования. Фасад (Facade)

### Определение и концепция
**Фасад (Facade)** — это структурный паттерн проектирования, который предоставляет унифицированный, упрощенный интерфейс к сложной системе классов, библиотеке или фреймворку. Паттерн скрывает внутреннюю сложность системы, предоставляя клиенту только необходимые методы.

### Основные цели
1. **Упрощение интерфейса** — предоставление простого интерфейса для сложной подсистемы
2. **Снижение связанности** — уменьшение зависимостей между клиентом и компонентами системы
3. **Инкапсуляция сложности** — сокрытие деталей реализации подсистемы
4. **Организация кода** — создание четкой точки входа в сложную систему

### Структура паттерна

!["СтруктураПаттернаФасад"](/factory_manager/exam/sources/Class_diagram.png)

### Компоненты паттерна

#### 1. **Фасад (Facade)**
- Основной класс, предоставляющий упрощенный интерфейс
- Делегирует запросы клиента соответствующим объектам подсистемы
- Может добавлять дополнительную логику между запросом клиента и вызовами подсистемы
- **Не заменяет** подсистему, а только упрощает доступ к ней

#### 2. **Дополнительный фасад (Additional Facade)**
- Может быть создан для предотвращения "загрязнения" основного фасада
- Выносит часть функциональности в отдельные классы
- Позволяет разделить фасад на более мелкие и специализированные интерфейсы

#### 3. **Сложная подсистема (Complex Subsystem)**
- Состоит из множества разнородных объектов
- Для работы подсистемы требуются глубокие знания о ее внутреннем устройстве
- Классы подсистемы не знают о существовании фасада

#### 4. **Клиент (Client)**
- Использует фасад вместо прямого взаимодействия с объектами подсистемы
- Получает простой и понятный интерфейс
- Может продолжать использовать объекты подсистемы напрямую, если это необходимо

### Принцип работы
1. Клиент обращается к фасаду с запросом
2. Фасад перенаправляет запрос соответствующим объектам подсистемы
3. Объекты подсистемы выполняют работу
4. Фасад агрегирует результаты и возвращает их клиенту
5. Клиент получает простой ответ без знания о внутренней сложности

### Преимущества

#### 1. **Изоляция клиента от сложности**
```python
# Без фасада
subsystem_a = SubsystemA()
subsystem_b = SubsystemB()
subsystem_c = SubsystemC()

# Клиент должен знать последовательность вызовов
result1 = subsystem_a.initialize()
result2 = subsystem_b.setup(result1)
result3 = subsystem_c.configure(result2)
final_result = subsystem_a.finalize(result3)

# С фасадом
facade = Facade()
final_result = facade.simple_operation()  # Вся сложность скрыта
```

#### 2. **Снижение связанности**
- Клиент зависит только от фасада, а не от всех классов подсистемы
- Изменения в подсистеме минимально затрагивают клиентский код
- Упрощается тестирование и поддержка

#### 3. **Улучшение читаемости и поддерживаемости**
- Код клиента становится чище и понятнее
- Логика работы с подсистемой централизована в одном месте
- Упрощается рефакторинг и модификация системы

### Недостатки

#### 1. **Риск создания "божественного объекта" (God Object)**
- Фасад может стать слишком большим и сложным
- Решение: создание дополнительных фасадов

#### 2. **Дополнительный уровень абстракции**
- Увеличивает сложность архитектуры
- Может замедлить выполнение (незначительно)

### Когда использовать паттерн Фасад

#### 1. **Для упрощения сложной системы**
- Когда система имеет много взаимосвязанных классов
- Когда клиентам требуется только часть функциональности системы

#### 2. **Для разделения подсистем**
- Когда нужно разбить систему на слои
- Для создания четких точек входа в каждый слой

#### 3. **При интеграции сторонних библиотек**
- Для создания удобного интерфейса к сложным библиотекам
- Для изоляции зависимостей от стороннего кода

#### 4. **В легаси-системах**
- Для модернизации устаревших систем без полной переработки
- Для создания современного интерфейса к старому коду

### Отношение с другими паттернами

#### **Фасад vs Адаптер (Adapter)**
- **Фасад** упрощает интерфейс, но не изменяет его
- **Адаптер** изменяет интерфейс для совместимости с другим кодом

#### **Фасад vs Посредник (Mediator)**
- **Фасад** предоставляет интерфейс к подсистеме
- **Посредник** централизует коммуникацию между компонентами

#### **Фасад vs Одиночка (Singleton)**
- Фасад часто реализуется как одиночка, но это не обязательно
- Можно иметь несколько экземпляров фасада с разной конфигурацией

### Практические аспекты реализации

#### 1. **Интерфейс фасада должен быть минимальным**
```python
class GoodFacade:
    # Хорошо: небольшой набор методов
    def process_order(self, order_data): ...
    def get_status(self, order_id): ...
    def cancel_order(self, order_id): ...

class BadFacade:
    # Плохо: слишком много методов
    def validate_order(self, order): ...
    def calculate_price(self, order): ...
    def check_inventory(self, items): ...
    def process_payment(self, payment): ...
    # ... и еще 20 методов
```

#### 2. **Фасад не должен ограничивать доступ к подсистеме**
```python
class FlexibleFacade:
    def __init__(self):
        self.subsystem = ComplexSubsystem()

    def simple_operation(self):
        # Предоставляет упрощенный интерфейс
        return self.subsystem.do_complex_thing()

    @property
    def subsystem_access(self):
        # Но также позволяет доступ к подсистеме
        return self.subsystem
```

### Базовый пример кода
```python
# Сложные подсистемы
class SubsystemA:
    def operation_a1(self):
        return "SubsystemA: Готов!"

    def operation_a2(self):
        return "SubsystemA: Выполняю!"

class SubsystemB:
    def operation_b1(self):
        return "SubsystemB: Готов!"

    def operation_b2(self):
        return "SubsystemB: Выполняю!"

class SubsystemC:
    def operation_c1(self):
        return "SubsystemC: Готов!"

    def operation_c2(self):
        return "SubsystemC: Выполняю!"

# Фасад
class Facade:
    def __init__(self):
        self.subsystem_a = SubsystemA()
        self.subsystem_b = SubsystemB()
        self.subsystem_c = SubsystemC()

    def operation(self):
        """Простой интерфейс для клиента"""
        results = []
        results.append(self.subsystem_a.operation_a1())
        results.append(self.subsystem_b.operation_b1())
        results.append(self.subsystem_c.operation_c1())
        results.append(self.subsystem_a.operation_a2())
        results.append(self.subsystem_b.operation_b2())
        results.append(self.subsystem_c.operation_c2())
        return "\n".join(results)

# Клиентский код
def client_code(facade: Facade):
    print(facade.operation())

# Использование
facade = Facade()
client_code(facade)
```

Подробно рассмотреть реализацию данного паттерна можно в папке factory_manager_project